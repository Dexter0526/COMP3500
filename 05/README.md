# 5. 암호화
- 평문(plaintext)을 암호문(ciphertext) 으로 변환하는 것
  - 평문 : 누구나 읽으면 곧바로 이해할 수 있는 정보
  - 암호문 : 읽는다고 모두가 이해할 수는 없는 정보
- 단, 특별한 정보를 아는 사람만 이해할 수 있음

#### 복호화
- 암호문을 다시 평문으로 변환하는 것
- 암호화에 사용한 방법을 알아야 복호화 가능

#### 해시 알고리즘과 암호화의 차이점
- 해시 알고리즘은 원문 복구를 막는게 목표
- 암호화 알고리즘은 원문 복구를 허용해야함

#### 암호화의 역사
- 고대 그리스, 로마에서도 군용 목적으로 사용
- 19~20세기에는 특히 군용으로 많이 사용
  - 무전으로 보내는 군사 정보
  - 2차 세계 대전중 독일군이 사용한 에니그마 기계
- 현대 사회에서는 모든것을 암호화해야 함
  - 전화 혹은 온라인을 통해 타인과 대화하는 일이 많아짐
  - 온라인에 저장된 정보가 너무 많음
  
## 정수론(number theory)
- 정수의 성질에 대한 연구하는 학문
- 2진수로 표현된 데이터를 암호화하려다 보니 갑자기 주목 받음
- 소수에 관련된 정수론적 알고리즘이 많은 주목을 받음
  - 암호문의 패턴을 들키지 않으려면 겹치지 않는 수가 필요
  - 소수는 자연에서 가장 안 겹치는 수
  
### 암호학에서 사용하는 정수
- 매우 큰 정수
  - 흔히 사용하는 32비트 등의 정수가 아님
- 입력 크기 N(N : 비트수)
  - 보통 배열 속의 요소 수를 의미
  - 암호학에서 사용하는 정수에서는 비트 수를 의미
- 곱셈, 나눗셈, 나머지 연산의 시간 복잡도
  - 보통 정수 : O(1)
  - 암호학에서 사용하는 정수는 비트 수에 비례
  
### 현대에서 사용하는 암호화 알고리즘 두 종류
- 대칭 키 암호화
  - 암호화/복호화에 동일한 키를 사용
- 비대칭 키 암호화
  - 공개 키 암호화라고도 함
  - 암호화와 복호화에 사용하는 키가 다름
  
## 대칭 키 암호화
- 암호화/복호화에 동일한 키를 사용
- 이 키는 메시지 송신자와 수신자가 공유하는 비밀
- 송신자가 수신자에게 비밀스럽게 키를 알려줄 방법이 필요

### 스트림 암호 vs 블록 암호
- 스트림 암호의 예
  - 한번에 1바이트씩 받아 암호화를 진행
  - 안전하려면 각 바이트에 적용하는 키가 달라야 함
    - 보통 시드 값을 정하고 난수로 생성
  - 블록 암호보다 설정이 복잡하나 속도가 빠름
- 블록 암호
  - 정해진 블록 크기(64비트 이상) 만큼의 바이트를 한번에 암호화
  - 각 블록에 사용하는 키가 동일함
  - 스트림 암호보다 설정이 간단하나 속도가 느림
  
#### Wi-Fi 비밀번호도 일종의 대칭 키
- WPA2-Personal
  - 스마트폰이 처음 공유기에 접속 시 교환하는 어떤 값과 비밀번호를 합쳐 키 생성
  - 그 키를 이용해서 메세지를 암호화
  - 모든 접속자마다 다른 키를 사용
  - 하지만 해커가 둘 사이의 모든 트래픽을 캡처한다면 읽기 가능
  
### AES
- NSA에서 일급비밀 용으로 승인한 유일한 공개 암호화 알고리즘
- 현재 가장 널리 사용되는 대칭 키 알고리즘
  - WPA2 프로토콜의 일부로 사용되기도 함
- 블록 크기 : 128비트
- 키 길이 : 128, 192 또는 256비트
  - 128비트 : 10라운드
  - 192비트 : 12라운드
  - 256비트 : 14라운드
  
#### AES의 블록
- 한번에 16바이트씩 읽어서 암호화
- 4 x 4 행렬로 배치

#### AES 알고리즘의 구성
1. 키 확장
2. 0라운드
    1) 라운드 키 더하기
3. 9/11/13 라운드
    1) 바이트 대체 (룩업 테이블을 사용) - 혼돈(confusion)효과를 성취
    2) 행 이동 - 확산효과를 성취
    3) 열 섞기 (행렬 x 벡터 곱을 이용) - 확산(diffuse)효과를 성취
    4) 라운드 키 더하기
4. 최종 라운드(총 라운드 수가 10/12/14가 됨)
    1) 바이트 대체
    2) 행 이동
    3) 라운드 키 더하기
    
## 비대칭 키 암호화
- 암호화와 복호화에서 사용하는 키가 다름
- 두 키 사이에는 특수한 수학적인 관계가 있음
    - 둘 중 한 키로 암호화한 메세지를 다른 키로 복호화할 수 있음
- 따라서 키 하나는 완전히 공개해 놓아도 상관없음
    - 이 키를 공개 키(public key)라고 부름
- 다른 키 하나는 한 개인이 비밀로 가지고 있음
    - 이 키를 비밀 키 또는 개인 키(private key)라고 부름
    
### 비대칭 키 암호화의 두 가지 주요 용도
- 전송하는 메세지의 암호화
    - 송신자가 수신자의 공개 키로 원문 -> 암호문
        - 키가 공개돼 있으니 누구나 암호화 가능
        - 공개 키로는 암호문 -> 원문 변환 불가
    - 수신자는 자신의 비밀 키로 암호문 -> 원문 변환
        - 수신자만 알고 있는 키
        - 수신자만 원문을 볼 수 있음
- 전자서명(digital signature)
    - 메세지는 누구든 볼 수 있음
    - 메세지 송신자가 올바름을 증명
    - 암호화폐에서 돈을 옮길 때도 이 방법을 사용
    
### 비대칭 키 암호화를 사용하는 곳
- HTTPS
    - 비대칭 키 암호화와 더불어 대칭 키 암호화도 사용
- 메신저 앱의 비밀 채팅 모드
    - 서버도 내 비밀 키를 모르는 모드
- 비트코인 등의 암호화폐 프로토콜
- Git 커밋의 전자서명

### 암호화 기법
- 디피-헬만 키 교환
- **RSA**
- 디지털 서명 알고리즘
- 타원곡선 DSA

### RSA
- 현재 데이터 전송용으로 매우 널리 쓰이는 암호화 기법
- 정수론에 기초
- 공개 키/비밀 키 쌍을 만드는게 매우 쉬움
    - 매우 큰 두 소수를 이용
- 이 두 키는 특수한 수학적 관계를 가짐
    - 공개 키를 알아도 그로부터 비밀 키를 찾기 매우 힘듦
    
#### RSA가 이용하는 소수의 성질
- 두 소수를 곱하는 것은 누구나 쉽게 할 수 있는 연산
- 두 소수를 곱한 합성수에서 그 소수들을 찾는 것은 훨씬 어려움

#### RSA 키 길이와 연산 속도
- NIST에서 권하는 RSA의 키 길이
    - 2002년 : 1024비트
    - 2015년 : 2048비트
- RSA-2048은 1024 비트 소수를 2개 사용
    - 2^1024 = 1.798 * 10^308
    - 즉, 308자리 숫자

#### RSA 공개 키/비밀 키의 기초
- "비밀키" : 아주 큰 소수 p,q
- "공개키" : 합성수 n (n = p * q)
- p, q를 모르면 n으로부터 p, q를 찾기개 매우 힘듦(첫 번째 특수한 관계)
- p, q와 특수한, 그리고 서로 간에도 특수한 관계인 e와 d를 찾음(두 번째 특수한 관계)
    - e : 공개 키의 두 번째 요소
    - d : 비밀 키의 두 번째 요소
    - e와 d는 다음 관계를 만족해야 함
        - (m^e)^d = m(mod n)
        - de = 1(mode λ(n))
    
##### 합동식(modular congruence)
a ≡ b (mod n),  1 < n
- mod n이 좌항/우항에 모두 적용됨(a = b % n과 다름)
- a - b = kn
- a % n = b % n

#### RSA 키 생성
1. 매우 큰 두 소수 p, q를 찾는다
    1) 매우 큰 랜덤 수를 뽑는다
    2) 그 수가 소수인지 판별한다
    3) 소수가 아니라고 판별되면 1번 단계로 돌아간다
    4) 서로 다른 두 소수를 찾을 때까지 이 과정을 반복한다
2. p와 q를 곱해 n을 만든다
3. p, q와 특수한 수학적 관계인 e를 찾는다
    1) n의 카마이클 수를 구한다 : λ(n) = lcm(p - 1, q - 1)
    2) 1 < e < λ(n) 이고 λ(n)과 서로소인 e값을 찾는다
4. e와 특수한 수학적 관계인 d를 찾는다
    - de = 1(mode λ(n))
    - 위 조건을 만족하는 d를 찾음
    - 확장 유클리드 호제법을 사용
    - e와 λ(n)이 서로소이면 반드시 위 조건을 만족하는 d가 존재
    
<pre>
ex) RSA 키 생성
p = 67, q = 53
n = 67 * 53 = 3551
λ(n) = lcm(66, 52) = 1716
e = 19, 1 < 19 < 1716, 19는 소수이며, 1716 % 19 = 6
d = 271, 271 * 19 % 1716 = 1
</pre>

#### RSA를 이용한 암호화 / 복호화
m^e % n = c ... 암호화  
c^d % n = m ... 복호화

- m : 원문
    - 반드시 m < n 이어야 함
- c : 암호문

#### RSA 증명
<pre>
- 암호화 : c = m^e % n -> c ≡ m^e (mod n)
- 이로부터 도출 가능한 식 : c^d ≡ (m^e)^d (mod n)
- 복호화 공식이 m을 돌려줌을 증명하고 싶음
    - 위 도출식의 좌항 : c^d % n
    - 복호화 공식 : c^d % n = m -> c^d ≡ m (mod n) (∵ m < n)
- 증명할 관계 : (m^e)^d ≡ m(mod n)
    - 앞에서 본 규칙에 따라 선택한 모든 e, d에 대해

m^(ed) ≡ m(mod pq)
ed ≡ 1(mode λ(pq))
ed ≡ 1(mod lcm(p - 1, q - 1))
ed - 1 = x * lcm(p - 1, q -1 )
∴ ed - 1은 최소공배수(p - 1, q - 1)의 배수

ed-1 = h(p-1)
ed-1 = k(q-1)
ed - 1은 p - 1의 배수, q - 1의 배수

m^(ed) ≡ m(mod pq)
-> m^(ed) ≡ m(mod p) 그리고 m^(ed) ≡ m(mod q) ... 중국인의 나머지 정리의 일부

1. m^(ed) ≡ m(mod p)의 증명
- 두가지 경우로 나눠서 증명
    a) m ≡ 0 (mod p): m이 p의 배수인 경우
    b) m !≡ 0 (mod p): m이 p의 배수가 아닌 경우
- 위 두가지가 모든 경우를 포함
2. m^(ed) ≡ m(mod q)의 증명

a) m ≡ 0 (mod p): m이 p의 배수인 경우
    m^(ed) ≡ m(mod p)
    m^(ed) ≡ 0 ≡ m(mod p)
- m은 p의 배수
∴ m^(ed)도 p의 배수

b) m !≡ 0 (mod p): m이 p의 배수가 아닌 경우
    m^(ed) ≡ m(mod p)
    m * m^(ed-1) ≡ m(mod p)
    m * m^(h(p-1)) ≡ m(mod p) ... ed-1 = h(p-1)
    m * (m^(p-1)^h) ≡ m(mod p)
    m * 1^h ≡ m(mod p) ... 페르마의 소정리
    ∴ m ≡ m(mod p) ≡ m^(ed)
</pre>
