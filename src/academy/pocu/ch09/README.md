# 9. 동적 계획법, 그리디 알고리즘

## 동적 계획법(dynamic programming, dp)
- 특별한 속성을 가진 복잡한 문제를 푸는 방법
- 복잡한 문제를 그보다 단순한 하위 문제로 나눠서 풂
  - 재귀적
  - 가장 단순한 문제 + 1은 그 다음으로 단순한 문제
  - 이걸 반복하면 원래의 복잡한 문제까지 해결
- 당연히 모든 문제를 이렇게 풀 수는 없음
  - 특별한 속성이 필요
  
#### 배낭(knapsack) 문제
- 크기와 가격이 다른 여러 물품이 있음
- 값어치가 최대가 되도록 물건 넣기
- 당연히 배낭에는 크기 제한이 있음
- 판정 버전은 약한 NP-완전 문제
  - "최소 어떤 값어지 V만큼 넣을 수 있는가?"
  - 의사 다항식 시간 안에 풀 수 있음
- 시간 복잡도 : O(2^n)

### 메모이제이션(memoization)
- 계산 결과를 캐시에 저장해 둔 뒤, 나중에 재사용하는 기법
  - **처음 계산할 때 그 결과를 캐시에 저장**
  - 나중에 동일한 계산을 다시 하는 대신 저장해둔 값을 가져다 씀
  - 값비싼 계산(예: 깊은 재귀 호출)에 적합
  - 최적화 기법 중 하나, 캐싱 기법 중 하나
- 보통 함수가 매개변수에 따라 반환하는 값을 캐싱하는 것을 지칭
- 컴퓨터 프로그래밍에서만 사용하는 용어

```
메모이제이션을 사용한 피보나치 함수
public static int fibonacciRecursive(int number, int[] cache){
  if(number <= 1){
    return number;
  }
  
  if(cache[number] != 0){
    return cache[number];
  }
  
  int ret = fibonacciRecursive(number - 2, cache)
              + fibonacciRecursive(number - 1, cache);
  cache[number] = ret;
  
  return ret;
}
```

### 동적 계획법과 메모이제이션
- 전혀 다른 개념
  - 메모이제이션 : 실행된 결과를 기억해뒀다가 재사용하는 최적화 기법
  - 동적 계획법 : 복잡한 문제를 하위 문제로 쪼개서 재귀적으로 푸는 방법
- 하지만 동적 계획법 = 메모이제이션이라 흔히 오해함
  - 메모이제이션이 동적 계획법에 필수가 아님
  - 동적 계획법의 성능을 향상할 뿐
- 다른 곳에서도 메모이제이션을 사용함

#### top-down 동적 계획법
- 최종적으로 풀려고 하는 복잡한 문제(루트)에서 시작
- 필요에 따라 재귀적으로 하위 문제를 풂
  - 두번 이상 평가하는 문제는 캐시 덕분에 계산 생략
  - 하위 문제를 평가하는 최적의 순서를 알 필요 없음
- 기존의 재귀 함수를 크게 변경하지 않아도 됨
  - 그냥 캐시 로직 추가
  - 생각해 내기도 구현하기도 편함
  

#### 타뷸레이션(tabulation)
bottom-up 방식
```
public static int fibonacci(int number){
  int cache[] = new int[number + 1];
  cache[0] = 0;
  cache[1] = 1;
  
  for(int i = 2; i <= number; i++){
    cache[i] = cache[i - 2] + cache[i - 1];
  }
  
  return cache[number];
}
```
- 가장 작은 문제(리프)부터 시작
- 순서대로 그보다 하나 더 큰 문제를 풀어나감
  - 필요하지 않은 하위 문제도 평가할 수 있음
  - 문제를 잘 분석해서 최적의 순서를 찾아야 함
- top-down 방식보다 보통 더 빠름
  - CPU 캐시에 좀 더 친화적
  - 재귀 함수 호출을 피할 수 있음
  - 모든 하위 문제를 평가할 필요가 없는 경우에는 예외
  
#### 동적 계획법으로 푸는 배낭 문제
- 작은 배낭부터 최적의 해법을 찾아나감
  - 예: 1칸 배낭 -> 2칸 배낭 -> 3칸 배낭 -> ...
- 우선 그리드를 만든다
  - 모든 동적 계획법 알고리즘은 그리드로 시작
  - 각 cell 마다 간단한 결정(훔침 vs 안 훔침)을 내림
  - 각 cell의 값은 훔칠 수 있는 최댓값
  
|물품|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|리코더|0|0|0|0|5|5|5|5|5|5|5|5|5|5|5|
|책|0|0|0|2|5|5|5|5|7|---|---|---|---|---|---|
|사슴|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|

1. 리코더 ($5 / 5칸)
    - 첫 물품부터 고려
    - 리코더를 1~15칸 배낭에 넣을 때 가치를 계산
  
2. +책 ($2 / 4칸)
    - 윗행의 결과에 책을 추가로 고려할 차례
      - 역시 1~15칸 배낭마다
    - 책을 추가할 수도 아닐 수도
    - 책을 추가하면서 리코더를 뺄 수도 아닐 수도
  
