# 그래프 1

![img.png](img/img.png)

- 데이터들과 그 관계를 보여주는 방법 중 하나
- 서로 연관있는 노드의 집합
    - G = (N, E)
- 네트워크 형태의 관계를 보여주기에 적합
- 복잡한 실세계의 문제를 모델링하기에 적절
    - 네트워크 형태가 명백하게 안 보이는 경우도 있음
    - 그래프 이론을 적절히 적용하면 시간 복잡도를 확연히 줄일 수도 있음
    
#### 그래프 사용 예
- 지하철 노선도
- 교과 선수과목
- 전/현 직장동료
- 세탁기 사이클
- 스킬 트리(트리 : 방향 비순환 그래프 중 하나)

#### 관련 용어
- 노드(정점, 꼭지점)
- 변(간선, 선)
- 차수(degree)
- 루프(loop)

### 그래프 종류
- 방향/무방향 그래프
- 순환/비순환 그래프
- 가중/비가중 그래프

#### 방향 vs 무방향 그래프
- 방향 그래프(세탁기 사이클)
    - 변이 한 방향만 가리킴
    - 꼬리 -> 머리로 이동은 가능
    - 머리 -> 꼬리 이동은 불가능
- 무방향 그래프(인간 관계)
    - 변에 특별한 방향이 없음
    - 따라서 양방향을 가리키는 것과 같음
    - 꼬리 -> 머리, 머리 -> 꼬리 모두 가능
    
무방향 그래프의 최대 변 개수
- 모든 노드가 연결되어 있는 경우
    - 단, 평행 변이나 루프는 없음
- 첫 번째 노드의 변 : N - 1개
- 두 번째 노드의 변 : N - 2개
- 세 번째 노드의 변 : N - 3개

#### 순환 vs 비순환 그래프
- 비순환 그래프(교과 선수과목)
    - 일단 떠나면 그 노드로 돌아오는 경로가 없음
    - 그래프 안의 모든 노드에 대해
- 순환 그래프(지하철 노선)
    - 떠난 뒤에도 그 노드로 돌아오는 경로가 있음
    - 그런 노드가 하나만 있어도 순환 그래프
    
#### 가중 vs 비가중 그래프
- 비가중 그래프
    - 모든 변이 동일한 의미를 가짐
    - 각 변의 값이 같음
    - 별도의 표기 불필요
- 가중 그래프
    - 각 변의 관계 정도가 다름(예: 거리, 시간...)
    - 각 변의 값이 다름
    
### 그래프를 사용해 풀 수 있는 문제들
- 여러 스케줄링 관련
- 두 위치 사이의 여행 경로 관련
- 분자를 구성하는 원자들의 결합 관련
- 인터넷에서 데이터 패킷이 전달되는 경로 관련
- 대규모 프로젝트에서 일감 사이의 의존성 관련
- 도시의 전기 공급 그리드 관련
- SNS에서 친구 관계 관련

### 그래프의 다양한 표현 방법
#### 1. 원과 선
- 사람이 가장 이해하기 쉬운 표현법
- 한눈에 그래프를 파악 가능
- 단, 노드와 변의 수가 적당해야 함
```
public class Node{
    public int data;
    public ArrayList<Node> neighbors = new ArrayList<>();
}
```
#### 2. 인접 행렬(adjacency matrix)
- N x N 행렬
    - G[n][n]
    - N: 그래프 G안에 있는 노드 수
- 서로 인접한 노드를 표현
    - 인접: 두 노드 사이를 연결하는 변이 있음
    - i에서 j로 향하는 변이 있다면 G[i][j] = 1
    - 없으면 G[i][j] = 0
- G가 가중 그래프면 0/1 대신 실제 가중치를 저장
    
![img.png](img/img_1.png)

|---|A|B|C|D|
|---|---|---|---|---|
|A|0|1|1|0|
|B|1|0|1|1|
|C|1|1|0|0|
|D|0|1|0|0|

![img.png](img/img_2.png)

|---|A|B|C|D|
|---|---|---|---|---|
|A|0|0|1|0|
|B|1|0|0|1|
|C|0|1|0|0|
|D|0|0|0|0|

- 가로 방향 : 주체가 대상에 방향성이 있음
- 세로 방향 : 대상에 주체에게 방향성이 있음

장점
- 쉽게 구현 가능
- 변 제거의 시간 복잡도가 O(1)
- 다음과 같은 관계를 효율적으로 찾음
    - 노드 A에서 B로 가는 변이 존재하는가?
    - O(1)
    
단점
- 공간을 더 차지함 O(N^2)
- 언제나 같은 공간을 차지
    - 연결된 노드가 많아도/적어도
- 인접 행렬을 만드는 시간은 O(N^2)
- 인접 노드를 찾는 시간은 O(N)

#### 3. 인접 리스트(adjacency list)
- 각 노드마다 이웃의 리스트를 만듦
    - 리스트 N개
    - 보통 연결 리스트 N개를 배열에 저장
    - 연결 리스트 대신 다른 자료구조도 사용 가능
- 원과 선을 굳이 코드로 구현한 것과 큰 차이가 없음

장점
- 공간을 적게 사용
    - O(N + E)
    - 최악 : O(N^2) = O(N + N(N-1)/2)
- 삽입/삭제가 빠름
    - 연결 리스트를 사용했을 경우

단점
- 다음과 같은 관계를 찾는게 느림
    - 노드 A에서 B로 가는 변이 존재하는가?
    - O(1)보다 느림
    
#### 4. 기타 표현 방법
- 결합 행렬(incidence matrix)
- 결합 리스트(incidence list)
- ...

## 그래프의 깊이 우선 탐색
![img.png](img/img_3.png)
```
무한 루프
public static void searchDepthFirst(Node node){
    Stack<Node> stack = new Stack<>();
    stack.push(node);
    
    while(!stack.empty()){
        Node next = stack.pop();
        
        System.out.println(next.data);
        
        for(Node child : next.children){
            stack.push(child);
        }
    }
}
```

### 무한 루프 해결법
- 이미 처리했던 노드를 다시 처리하면 안됨
- 방문했던 노드를 기억할 방법이 필요
    - 전역적으로 방문했던 노드를 기억
    - 각 노드마다 방문했는지 여부를 기억
- 두 번째 방문시 처리 안 하고 곧바로 다음 노드로 넘어감

```
무한 루프 해결
public static void searchDepthFirst(Node node){
    HashSet<Node> visited = new HashSet<>();
    Stack<Node> stack = new Stack<>();
    stack.push(node);
    
    while(!stack.empty()){
        Node next = stack.pop();
        
        System.out.println(next.data);
        visited.add(next);
        for(Node neighbor : next.neighbors){
            if(!visited.contains(neighbor)){
               stack.push(neighbor);
            }
        }
    }
}

발견한 노드 기억하기
public static void searchDepthFirst(Node node){
    HashSet<Node> discovered = new HashSet<>();
    Stack<Node> stack = new Stack<>();
    stack.push(node);
    discovered.add(node);
    
    while(!stack.empty()){
        Node next = stack.pop();
        
        System.out.println(next.data);

        for(Node neighbor : next.neighbors){
            if(!discovered.contains(neighbor)){
               stack.push(neighbor);
               discovered.add(neighbor);
            }
        }
    }
}
```

## 위상정렬
- 그래프의 노드를 선형(일직선)으로 정렬하는 방법
- 우선순위가 바뀌지 않음
  - 예: B 노드를 가리키던 모든 노드들이 B 보다 전에 나옴
- DAG만 유효한 위상 정렬이 가능
  - 순환(cycle)하는 노드가 있다면 우선순위 판단이 불가능
  - 시작점이 존재해야 함
- 해답이 여럿일 수도 있음

예) DAG
![img.png](img/img_5.png)

위상 정렬
![img.png](img/img_4.png)


#### 위상 정렬 알고리즘
- DFS
- 칸 알고리즘
- 크게 두 가지 용도
  - 실제로 위상 정렬을 함
  - 위상 정렬 가능한 그래프인지 판단
  
### DFS를 사용한 위상 정렬
DFS만으로 간단히 위상 정렬을 할 수 있음

#### 물 받기부터 시작하는 전위 순회
1. 물 받기
2. 스프 넣기
3. 물 끓이기
4. 라면 넣기
5. 파 넣기
6. 2분 더 끓이기
7. 계란 넣기
8. 1분 더 끓이기
9. 먹기
10. 건더기 넣기
11. 라면 봉지 뜯기
12. 파 썰기
13. 수저 넣기

#### 물 받기부터 시작하는 후위 순회
1. 먹기
2. 1분 더 끓이기
3. 계란 넣기
4. 2분 더 끓이기
5. 파 넣기
6. 라면 넣기
7. 물 끓이기
8. 스프 넣기
9. 건더기 넣기
10. 물 받기
11. 라면 봉지 뜯기
12. 파 썰기
13. 수저 놓기

### 위상 정렬 용도
- 관계에서 순서를 정하는 매우 많은 곳에 사용 가능
  - 프로젝트 일정 만들기
  - CPU 명령어 실행 순서 결정
  - 스프레드 시트 셀 평가 순서 결정
  - 컴파일 순서 결정
  - DB 테이블 로딩 순서 결정
  - 선수 순위 결정
  
